#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <stdio.h>
#include <vector>

int GLOBAL_store_variable;
int GLOBAL_user_input;
int GLOBAL_display_OP1;
int GLOBAL_cls;
int GLOBAL_newline;
int GLOBAL_protect_b;

using namespace std;
class Header
{
public:
  Header(){};
  ~Header(){};
  friend ostream &operator << (ostream &out, const Header &c); 
};

ostream & operator << (ostream &out, const Header &C) 
{
  out << ";;; Code Generated by ticc" << endl;
  out << ";;; Program Name:" << endl;
  out << ";;; Author:" << endl;
  out << ";;; Date:" << endl;
  out << ";;; ======================" << endl;
  out << "#include \"ti83plus.inc\"\n#define progstart $9D95\n.org progStart-2\n.db $BB,$6D\n\tbCall( _RunIndicOff )" << endl;
  return out;
}


class Footer
{
public:
  Footer(){};
  ~Footer(){};
  friend ostream &operator << (ostream &out, const Footer &c);
  
};
ostream & operator << (ostream &out, const Footer &C) 
{
  if( GLOBAL_store_variable == 1 )
    {
      out << ";; ============================================ ;;" << endl;
      out << ";; STORE VARIABLE FUNCTION                      ;;" << endl;
      out << ";; ============================================ ;;" << endl;
      out << "storeVariable:" << endl;
      out << "\tld (variabletoken), a" << endl;
      out << "\tld de, variabledata" << endl;
      out << "\tld bc, $09" << endl;
      out << "\tldir" << endl;
      
      out << "\tpush hl" << endl;
      out << "\tpush de" << endl;
      out << "\tpush bc" << endl;
      out << "\tld hl, variablename" << endl;
      out << "\trst $0020; bCall( _Mov9toOP1 )" << endl;
      out << "\tbCall( _FindSym )	; " << endl;
      out << "\tjr c, storeVAR" << endl;
      out << "\tbCall( _DelVar )" << endl;
      out << "storeVAR:" << endl;
      out << "\tld hl, $09" << endl;
      out << "\tbCall( _CreateReal )" << endl;
      out << "\tld hl, variabledata" << endl;
      out << "\tld bc, $09" << endl;
      out << "\tldir" << endl;
      
      out << "\txor a" << endl;
      out << "\tld (variabletoken), a" << endl;
      
      out << "\tpop bc" << endl;
      out << "\tpop de" << endl;
      out << "\tpop hl" << endl;
      out << "\tret" << endl;
      out << "variablename:" << endl;
      out << ".db RealObj" << endl;
      out << "variabletoken:" << endl;
      out << ".db $00, $00, $00" << endl;
      out << "variabledata:" << endl;
      out << ".db $00, $00, $00, $00, $00, $00, $00, $00, $00" << endl;
      out << ";; ============================================ ;;" << endl;
    }
  if( GLOBAL_cls == 1 )
    {
      out << "clsA:" << endl;
      out << "\tpush bc" << endl;
      out << "\txor a" << endl;
      out << "\tld (CurCol),a" << endl;
      out << "\tld (CurRow),a" << endl;
      out << "\tbCall(_ClrLCDFull)" << endl;
      out << "\tpop bc" << endl;
      out << "\tret" << endl;
    }
  if( GLOBAL_display_OP1 == 1 )
    {
      out << "dispOP1:" << endl;
      out << "\tpush bc" << endl;
      out << "\tld a, $09" << endl;
      out << "\tbCall( _FormReal )" << endl;
      out << "\tld hl, OP3" << endl;
      out << "\tbCall( _PutS )" << endl;
      out << "\tbCall( _NewLine )" << endl;
      out << "\tpop bc" << endl;
      out << "\tret" << endl;
    }
  if( GLOBAL_user_input == 1 )
    {
      out << ";;=======================================" << endl;

      out << "readkeyA:" << endl;
      out << "\tpush af" << endl;
      out << "\tpush hl" << endl;
      out << "readkeyA0:" << endl;
      out << "\tbCall(_GetCSC)" << endl;
      out << "\tor a" << endl;
      out << "\tjp z, readkeyA0" << endl;
      out << "\tcp sk0" << endl;
      out << "\tjp z, readkeyA_zero" << endl;
      out << "\tcp sk9" << endl;
      out << "\tjp z, readkeyA_nine" << endl;
      out << "\tcp sk8" << endl;
      out << "\tjp z, readkeyA_eight" << endl;
      out << "\tcp sk7" << endl;
      out << "\tjp z, readkeyA_seven" << endl;
      out << "\tcp sk6" << endl;
      out << "\tjp z, readkeyA_six" << endl;
      out << "\tcp sk5" << endl;
      out << "\tjp z, readkeyA_five" << endl;
      out << "\tcp sk4" << endl;
      out << "\tjp z, readkeyA_four" << endl;
      out << "\tcp sk3" << endl;
      out << "\tjp z, readkeyA_three" << endl;
      out << "\tcp sk2" << endl;
      out << "\tjp z, readkeyA_two" << endl;
      out << "\tcp sk1" << endl;
      out << "\tjp z, readkeyA_one" << endl;
      out << "\tcp skEnter" << endl;
      out << "\tjp z, readkeyA_cr" << endl;
      out << "\tcp skDecPnt" << endl;
      out << "\tjp z, readkeyA_decpt" << endl;
      out << "\tcp skSub" << endl;
      out << "\tjp z, readkeyA_negative" << endl;
      out << "\tcp skChs" << endl;
      out << "\tjp z, readkeyA_negative" << endl;
      out << "\tcp skLeft" << endl;
      out << "\tjp z, readkeyA_backspace" << endl;
      out << "\tcp skDel" << endl;
      out << "\tjp z, readkeyA_backspace" << endl;
      out << "\tjp readkeyA0" << endl;
      out << "readkeyA1:" << endl;
      out << "\tbCall( _PutC )" << endl;
      out << "readkeyA2:" << endl;
      out << "\tld (readkeyA_byte), a" << endl;
      out << "\tld hl, (text_buffer_ptr)" << endl;
      out << "\tld (hl), a" << endl;
      out << "\tinc hl" << endl;
      out << "\tld (text_buffer_ptr), hl" << endl;
      out << "\tld a, (text_buffer_length)" << endl;
      out << "\tinc a" << endl;
      out << "\tld (text_buffer_length), a" << endl;
      out << "\tpop hl" << endl;
      out << "\tpop af" << endl;
      out << "\tret" << endl;
      out << "readkeyA_zero:" << endl;
      out << "\tld a, $30" << endl;
      out << "\tjp readkeyA1" << endl;
      out << "readkeyA_nine:" << endl;
      out << "\tld a, $39" << endl;
      out << "\tjp readkeyA1" << endl;
      out << "readkeyA_eight:" << endl;
      out << "\tld a, $38" << endl;
      out << "\tjp readkeyA1" << endl;
      out << "readkeyA_seven:" << endl;
      out << "\tld a, $37" << endl;
      out << "\tjp readkeyA1" << endl;
      out << "readkeyA_six:" << endl;
      out << "\tld a, $36" << endl;
      out << "\tjp readkeyA1" << endl;
      out << "readkeyA_five:" << endl;
      out << "\tld a, $35" << endl;
      out << "\tjp readkeyA1" << endl;
      out << "readkeyA_four:" << endl;
      out << "\tld a, $34" << endl;
      out << "\tjp readkeyA1" << endl;
      out << "readkeyA_three:" << endl;
      out << "\tld a, $33" << endl;
      out << "\tjp readkeyA1" << endl;
      out << "readkeyA_two:" << endl;
      out << "\tld a, $32" << endl;
      out << "\tjp readkeyA1" << endl;
      out << "readkeyA_one:" << endl;
      out << "\tld a, $31" << endl;
      out << "\tjp readkeyA1" << endl;
      out << "readkeyA_cr:" << endl;
      out << "\tld a, (text_buffer_length)" << endl;
      out << "\tor a" << endl;
      out << "\tjp z, readkeyA0" << endl;
      out << "\tld a, $00" << endl;
      out << "\tjp readkeyA2" << endl;
      out << "readkeyA_decpt:" << endl;
      out << "\tld a, '.'" << endl;
      out << "\tbCall( _PutC )" << endl;
      out << "\tld a, tDecPt" << endl;
      out << "\tjp readkeyA2" << endl;
      out << "readkeyA_negative:" << endl;
      out << "\tld a, '-'" << endl;
      out << "\tbCall( _PutC )" << endl;
      out << "\tld a, tChs" << endl;
      out << "\tjp readkeyA2" << endl;
      out << "readkeyA_backspace:" << endl;
      out << "\tld a, (text_buffer_length)" << endl;
      out << "\tor a" << endl;
      out << "\tjp z, readkeyA0" << endl;
      out << "\tdec a" << endl;
      out << "\tld (text_buffer_length), a" << endl;
      out << "\tpush af" << endl;
      out << "\tld a, (CurCol)" << endl;
      out << "\tdec a" << endl;
      out << "\tld (CurCol),a" << endl;
      out << "\tld a, ' '" << endl;
      out << "\tbCall(_PutC)" << endl;
      out << "\tld a, (CurCol)" << endl;
      out << "\tdec a" << endl;
      out << "\tld (CurCol),a" << endl;
      out << "\tpop af" << endl;
      out << "\tpush hl" << endl;
      out << "\tld hl, (text_buffer_ptr)" << endl;
      out << "\tdec hl" << endl;
      out << "\tld (text_buffer_ptr), hl" << endl;
      out << "\tpop hl" << endl;
      out << "\tjp readkeyA0" << endl;
      out << "create_equation:" << endl;
      out << "\tld hl, equationName" << endl;
      out << "\trst $0020; bCall( _Mov9toOP1 )" << endl;
      out << "\tbCall( _FindSym )" << endl;
      out << "\tjr c, storeEqu" << endl;
      out << "\tbCall( _DelVar )" << endl;
      out << "storeEqu:" << endl;
      out << "\tld a, (text_buffer_length)" << endl;
      out << "\tld h, $00" << endl;
      out << "\tld l, a" << endl;
      out << "\tbCall( _CreateEqu ) " << endl;
      out << "\tinc de" << endl;
      out << "\tinc de" << endl;
      out << "\tld hl, text_buffer" << endl;
      out << "\tld a, (text_buffer_length)" << endl;
      out << "\tld b, $00" << endl;
      out << "\tld c, a" << endl;
      out << "\tldir" << endl;
      out << "\tret" << endl;
      out << "store9_hl:" << endl;
      out << ".dw $0000" << endl;
      out << "store9_de:" << endl;
      out << ".dw $0000" << endl;
      out << "getuserinput:" << endl;
      out << "\tpush hl" << endl;
      out << "\tpush af" << endl;
      out << "\tpush bc" << endl;
      out << "\tpush de" << endl;
      out << "\txor a" << endl;
      out << "\tld (text_buffer_length), a" << endl;
      out << "\tld hl, text_buffer" << endl;
      out << "\tld (text_buffer_ptr), hl" << endl;
      out << "\tld hl, prompt_text" << endl;
      out << "\tbCall( _PutS )" << endl;
      out << "readmore:" << endl;
      out << "\tcall readkeyA" << endl;
      out << "\tld a, (text_buffer_length)" << endl;
      out << "\tcp $18" << endl;
      out << "\tjp z, buffer_filled" << endl;
      out << "\tld a, (readkeyA_byte)" << endl;
      out << "\tor a" << endl;
      out << "\tjp z, buffer_filled" << endl;
      out << "\tjp readmore " << endl;
      out << "buffer_filled:" << endl;
      out << "\tld a, (text_buffer_length)" << endl;
      out << "\tdec a" << endl;
      out << "\tld (text_buffer_length), a" << endl;
      out << "\tcall create_equation" << endl;
      out << "\tld hl, equationName" << endl;
      out << "\tld de, OP1" << endl;
      out << "\tld bc, $04" << endl;
      out << "\tldir" << endl;
      out << "\tbCall( _ParseInp )" << endl;
      out << "\tld hl, OP1" << endl;
      out << "\tld de, FP_bfr" << endl;
      out << "\tld bc, $09" << endl;
      out << "\tldir" << endl;
      out << "\tld hl, equationName" << endl;
      out << "\trst $0020; bCall( _Mov9toOP1 )" << endl;
      out << "\tbCall( _FindSym )" << endl;
      out << "\tbCall( _DelVar )" << endl;
      out << "\tpop de" << endl;
      out << "\tpop bc" << endl;
      out << "\tpop af" << endl;
      out << "\tpop hl" << endl;
      out << "\tret" << endl;
      out << "FP_bfr:\n.db $00, $00, $00, $00, $00, $00, $00, $00, $00" << endl;
      out << "readkeyA_byte:\n.db $00" << endl;
      out << "equationName:\n.db EquObj, tVarEqu, tY3, $00" << endl;
      out << "text_buffer_length:\n.db $00" << endl;
      out << "text_buffer_ptr:\n.dw $0000" << endl;
      out << "text_buffer:\n.db $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00" << endl;
      out << "prompt_text:\n.db \"> \",0" << endl;

      out << ";;=======================================" << endl;
	 
      
    }


  
  return out;
}

class text
{
public:
  text(string c,string v)
  {
    value=v;
    codename=c;
  };
  
  friend ostream &operator << (ostream &out, const text &c); 
  
private:
  string value; // The actual quoted text that should display
  string codename; // The name given to the string in the source code
};

ostream & operator << (ostream &out, const text &C) 
{
  out << "TX_" << C.codename << ":" << endl;
  out << ".db \"" << C.value << "\",0" << endl;
  return out;
}

class var
{
public:
  var(string c)
  {
    codename=c;
  };
  
  friend ostream &operator << (ostream &out, const var &c); 
  
private:
  string codename; // The name given to the string in the source code
};

ostream & operator << (ostream &out, const var &C) 
{
  out << "FP_" << C.codename << ":" << endl;
  out << ".db $00, $00, $00, $00, $00, $00, $00, $00, $00" << endl;
  return out;
}

// OP1*mem
// OP2*mem
// OP1*OP2
// OP1/two
// OP1*two
class instr
{
public:
  instr(string i)
  {
#ifdef DEBUG
    cerr << "Processing: " << i << endl;
#endif
    instruction = i;
    if( i.substr(0,7) == "protect" ) GLOBAL_protect_b=1; // This is for comments
    if( i.substr(0,7) == "release" ) GLOBAL_protect_b=0; // This is for comments

    if( i.substr(0,1) == ";" ) code=i; // This is for comments
    if( i.substr(0,3) == "lbl" ) code="lbl_"+ i.substr(4,i.length())+":";
    if( i.substr(0,3) == "ret" ) code="\tret" ;
    if( i.substr(0,3) == "cls" )
      {
	GLOBAL_cls=1;
	code="\tcall clsA";
      }
    if( i.substr(0,4) == "crlf" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_NewLine)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	
      }
    if( i.substr(0,4) == "frac" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_ToFrac)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
    }
    
    if( i.substr(0,4) == "trig" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_Sin)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,4) == "swap" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_OP1ExOP2)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,4) == "seed" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_RandInit)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,4) == "rand" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_Random)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,7) == "OP1*OP2" )
      {
       	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_FPMult)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,5) == "OP1<0" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_ZeroOP1)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    
    if( i.substr(0,5) == "OP2<0" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_ZeroOP2)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    
    if( i.substr(0,7) == "OP1+OP2" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_FPAdd)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,7) == "OP1-OP2" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_FPSub)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,7) == "OP1/OP2" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code=+"\tbCall(_FPDiv)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }

    if( i.substr(0,7) == "ln(OP1)" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_LnX)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,8) == "log(OP1)" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_LogX)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,6) == "OP1^-1" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_FPRecip)";
 	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
     }
    if( i.substr(0,7) == "OP1^OP2" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_YToX)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,7) == "OP1*0.5" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_TimesPt5)";
 	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
     }
    if( i.substr(0,7) == "OP1^0.5" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_SqRoot)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,5) == "OP1^2" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_FPSquare)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,5) == "OP1*2" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_Times2)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }

    if( i.substr(0,11) == "if(OP1=OP2)" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_CpOP1OP2)\n";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";

	code+="\tjr z,lbl_"+i.substr(12,3)+"\n";	
      }
    if( i.substr(0,11) == "if(OP1>OP2)" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_OP1ExOp2)\n";
	code+="\tbCall(_CpOP1OP2)\n";
	code+="\tbCall(_OP1ExOp2)\n";
 	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	code+="\tjr c,lbl_"+i.substr(12,3)+"\n";	
	
      }
    if( i.substr(0,11) == "if(OP1<OP2)" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_CpOP1OP2)\n";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	code+="\tjr c,lbl_"+i.substr(12,3)+"\n";	
      }
    if( i.substr(0,12) == "if(OP1<=OP2)" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_OP1ExOp2)\n";
	code+="\tbCall(_CpOP1OP2)\n";
	code+="\tbCall(_OP1ExOp2)\n";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	code+=".db $38,$05\n";
	code+=".db $28,$03\n";
	code+="\tjp lbl_"+i.substr(12,3)+"\n";

      }
    if( i.substr(0,12) == "if(OP1>=OP2)" )
      {
	// if z and ca are zero
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_CpOP1OP2)\n";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	code+=".db $38,$05\n";
	code+=".db $28,$03\n";
	code+="\tjp lbl_"+i.substr(12,3)+"\n";
      }
    if( i.substr(0,9) == "if(OP1>0)" )
      {
	code=";; if(OP1>0) not implemented yet.";
      }
    if( i.substr(0,9) == "if(OP1<0)" )
      {
	code=";; if(OP1<0) not implemented yet.";
      }
    if( i.substr(0,9) == "if(OP1=0)" )
      {
	code=";; if(OP1=0) not implemented yet.";
      }
    if( i.substr(0,10) == "if(OP1<=0)" )
      {
	code=";; if(OP1<=0) not implemented yet.";
      }
    if( i.substr(0,10) == "if(OP1>=0)" )
      {
	code=";; if(OP1>=0) not implemented yet.";
      }
    

    
    if( i.substr(0,4) == "goto" )
      {
	code="\tjp lbl_"+i.substr(5,3)+"\n";
      }
    if( i.substr(0,5) == "round" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall( _Round )";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";

      }
    if( i.substr(0,5) == "input" )
      {
	GLOBAL_user_input=1;
	string _tmp = i.substr(6,i.length());
	code="\tcall getuserinput\n";
	code+="\tld hl, FP_bfr\n";
	code+="\tld de, FP_"+_tmp;
	code+="\n\tbCall( _Mov9B )";

      }
    if( i.substr(0,3) == "prn" )
      {
	if( i.substr(4,3) == "OP1" )
	  {
	    GLOBAL_display_OP1=1;
	    code="\tcall dispOP1";

	  }
	else
	  {
	    code="\tld hl, TX_" + i.substr(4,i.length())+"\n";
	    code+="\n\tbCall( _PutS )";
	  }
      }

    // mem-- FP_XXX
    if( i.substr(0,5) == "mem--" )
      {
	string _tmp = i.substr(6,3);
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";

	code+="\tbCall(_PushOP1)\n";
	code+="\tbCall(_PushOP2)\n";

	code+="\tld hl,FP_"+_tmp+"\n";
	code+="\trst $0020\n";

	code+="\tbCall(_OP2Set1)\n";

	code+="\tbCall(_FPSub)\n";

	code+="\tld hl, OP1\n\tld de, FP_"+_tmp+"\n";
	code+="\tbCall( _Mov9B )";

	code+="\tbCall(_PopOP2)\n";
	code+="\tbCall(_PopOP1)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";


      }

    if( i.substr(0,5) == "OP1--" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code+="\tbCall(_Minus1)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
    if( i.substr(0,5) == "OP1++" )
      {
	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	code="\tbCall(_Plus1)";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
      }
        // mem++ FP_XXX
    if( i.substr(0,5) == "mem++" )
      {
	string _tmp = i.substr(6,3);
 	code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";

	code+="\tbCall(_PushOP1)\n";
	code+="\tbCall(_PushOP2)\n";

	code+="\tld hl,FP_"+_tmp+"\n";
	code+="\trst $0020\n";

	code+="\tbCall(_OP2Set1)\n";

	code+="\tbCall(_FPAdd)\n";

	code+="\tld hl, OP1\n\tld de, FP_"+_tmp+"\n";
	code+="\tbCall( _Mov9B )";

	code+="\tbCall(_PopOP2)\n";
	code+="\tbCall(_PopOP1)";
 	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";

      }


    if( i.substr(0,3) == "asm" )
      {
	code=i.substr(3,i.length());
      }
    
    // OP1< ...
    if( i.substr(0,4) == "OP1<" )
      {
	
	if( i.substr(4,3) == "OP2" )
	  {
	    code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+="\tbCall( _OP2ToOP1 )";
	if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	  }
	else if( i.substr(4,3) == "mem" )
	  {	    
	    code+="\tld hl,FP_"+i.substr(8,i.length())+"\n";
	    code+="\trst $0020";
	  }
	else if( i.substr(4,4) == "varX" )
	  {
	    code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+="\tbCall(_RclX)";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	  }
	else if( i.substr(4,4) == "varY" )
	  {
	    code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+="\tbCall(_RclY)";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	  }
	else if( i.substr(4,3) == "var" )
	  {
	    // This will recall a tVar and put it into OP1
	    code="";
	    if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+="\tbCall( _ZeroOP1 )\n";
	    code+="\tld hl, op1+1\n";
	    code+="\tld (hl),'"+i.substr(8,i.length())+"'\n";
	    code+="\tbCall(_RclVarSym)";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	  }
	else if( i.substr(4,3) == "int" )
	  {
	    string _tmp = i.substr(8,i.length() );
	    code+="\tld a, "+_tmp+"\n";
	    if( GLOBAL_protect_b == 1) code+="\tpush bc\n";
	    code+="\tbCall(_SetXXOP1)";
	    if( GLOBAL_protect_b == 1) code+="\n\tpop bc";
	  }
      }
    
    if( i.substr(0,5) == "regb<" )
      {
	string _tmp=i.substr(6,i.length());
	code="\tld b,"+_tmp;
      }

    if( i.substr(0,5) == "b--" )
      {
	code="\tdec b";
      }
    if( i.substr(0,5) == "b++" )
      {
	code="\tinc b";
      }
    
    if( i.substr(0,5) == "loopb" )
      {
	string _tmp=i.substr(6,i.length());
	code="\tdjnz lbl_"+_tmp;
      }
    
    if( i.substr(0,4) == "OP1>" )
      {
	//Store OP1 somewhere
	if( i.substr(4,3) == "OP2" )
	  {
	    code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+="\tbCall( _OP1ToOP2 )";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	  }
	else if( i.substr(4,3) == "mem" )
	  {
	    code="\tld hl, OP1\n\tld de, FP_"+i.substr(8,i.length())+"\n\tbCall( _Mov9B )";
	  }
	else if( i.substr(4,4) == "varX" )
	  {
	    code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+="\tbCall(_StoX)";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	  }
	else if( i.substr(4,6) == "varAns" )
	  {
	    code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+="\tbCall(_StoAns)";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	  }
	else if( i.substr(4,4) == "varY" )
	  {
	    code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+="\tbCall(_StoY)";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	  }
	else if( i.substr(4,4) == "regb" )
	  {
	    code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+="; regb not yet implemented";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	    
	  }
	else if( i.substr(4,3) == "var" )
	  {
#ifdef DEBUG
	    cerr << "OP1>var t" << i.substr(8,i.length()) << endl;
#endif
	    GLOBAL_store_variable=1;
	    code="\tld a, t"+i.substr(8,i.length())+"\n";
	    code+="\tld (variabletoken), a\n\tld hl, OP1\n\tcall storeVariable";
	  }

      }


    // OP2<...
    if( i.substr(0,4) == "OP2<" )
      {
	if( i.substr(4,3) == "OP1" )
	  {
	    code="";
	if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+="\tbCall( _OP1ToOP2 )";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	  }
	else if( i.substr(4,3) == "mem" )
	  {
	    code="";
	    if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+=";; OP2<mem is not implemented yet.";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	    
	    //string _tmp = i.substr(8,i.length());
	    //code="\tld hl,FP_")+_tmp+string("\n";
	    //code+="\trst $0020";
	  }
	else if( i.substr(4,4) == "varX" )
	  {
	    code="";
	    if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+=";; OP2<varX is not implemented yet.";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	    //code="\tbCall(_RclX)";
	  }
	else if( i.substr(4,4) == "varY" )
	  {
	    code="";
	    if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+=";;; OP2<varY is not implemented yet.";
	    //code="\tbCall(_RclY)";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	  }
	else if( i.substr(4,3) == "var" )
	  {
	    code="";
	    if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    // This will recall a tVar and put it into OP2
	    code+="\tbCall( _ZeroOP2 )\n";
	    code+="\tld hl, op2+1\n";
	    code+="\tld (hl),'"+i.substr(8,i.length())+"'\n";
	    code+="\tbCall(_RclVarSym)";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	  }

      }

    
    // OP2> ...
    if( i.substr(0,4) == "OP2>" )
      {
	//Store OP2 somewhere
	if( i.substr(4,3) == "OP1" )
	  {
	    code="";
	    if( GLOBAL_protect_b==1 ) code+="\tpush bc\n";
	    code+="\tbCall( _OP2ToOP1 )";
	    if( GLOBAL_protect_b==1 ) code+="\n\tpop bc";
	  }
	else if( i.substr(4,3) == "mem" )
	  {
	    code="\tld hl, OP2\n\tld de, FP_"+i.substr(8,i.length())+"\n";
	    code+="\tbCall( _Mov9B )";
	  }
	else if( i.substr(4,3) == "var" )
	  {
	    GLOBAL_store_variable=1;
	    code="\tld a, t"+i.substr(8,i.length())+"\n";
	    code+="\tld (variabletoken), a\n\tld hl, OP2\n\tcall storeVariable";
	  }

      }

  };
  
  friend ostream &operator << (ostream &out, const instr &c); 
  
private:
  string instruction;
  string code;
};

ostream & operator << (ostream &out, const instr &C) 
{
  out << C.code << endl;
  return out;
}


int main(int argc, char *argv[])
{

  vector<text*> text_vector;
  vector<var*> var_vector;
  vector<instr*> instr_vector;
  Header * h = new Header();
  Footer * f = new Footer();
  GLOBAL_protect_b = 0;
#ifdef DEBUG  
    cerr << "There are " << argc << " arguments:" << endl;
    for (int i=0; i < argc; ++i) cerr << argv[i] << " ";
    cerr << endl;
#endif

#ifdef DEBUG
    cerr << "writing to " << argv[2] << endl;
#endif
    ifstream infile;
    infile.open(argv[1]);


    string line;
    
    if (infile.is_open())
      {
	// scan for TEXT to PRINT
	while ( getline(infile,line) )
	  {
	    if( line.substr(0,3) == string("str") )
	      {
		text_vector.push_back(  new text( line.substr(4,3), line.substr(8,line.length())));
	      }
	    else if( line.substr(0,3) == string("var") )
	      {
		var_vector.push_back( new var( line.substr(4,line.length())));
	      }
	    else
	      {
		// var to OP1
		instr_vector.push_back( new instr(line) );
	      }
	  }
	infile.close();
      }
    
    infile.close();

    ofstream outfile;

    outfile.open(argv[2]);

    outfile << *h;
    
    // CODE SEGMENT
    for( int i=0; i<instr_vector.size(); i++ )
    {
      outfile << *instr_vector[i] << endl;
    }

    outfile << *f;

    // DATA SEGMENT

    for( int i=0; i<text_vector.size(); i++ )
    {
      outfile << *text_vector[i] << endl;
    }

    for( int i=0; i<var_vector.size(); i++ )
    {
      outfile << *var_vector[i] << endl;
    }

    outfile.close();
    delete h;
    delete f;
    // Setup DATA segment if there is one

    // process instructions

    // close the source code file

    // create the assembler file

    // write out the assembler code
    // HEADER
    // USER CODE
    
    // FUNCTION CALLS
    // DATA SEGMENT

    
  // all went well, return 0
  return(0);
}
